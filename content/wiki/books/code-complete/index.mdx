---
title: Code Complete
slug: code-complete
book_author: Steve McConnell

---
## 5.3 Design Building Blocks: Heuristics

### Steps in designing objects (p. 87)

- Identify the objects and their attributes (methods and data).
- Determine what can be done to each object.
- Determine what can each object is allowed to do to other objects.
- Determine the parts of each object that will be visible to other objects—which parts will be public and which will be private.
- Define each object's public interface

> Abstraction is the ability to engage with a concept while safely ignoring some of its details—handling different details at different levels (p. 89).

> Encapsulation helps to manage complexity by forbidding you to look at the complexity (p. 90).

### Hide Secrets (Information Hiding)

Two reasons to hide information (p. 94):

1. Hiding **complexity** so that your brain doesn't have to deal with it unless you're specifically concerned with it.
2. Hiding **sources of change** so that when change occurs, the effects are localized.

> Minor changes to a system might affect several routines within a class, but they should not ripple beyond the class interface (p. 93).

> The interface to a class should reveal as little as possible about its inner workings (p. 94).

> Hiding a design decision makes a huge difference in the amount of code affected by a change (p. 95).

> While the road to programming hell is paved with global variables, class data presents far fewer risks (p. 95).

> Get into the habit of asking, "What should I hide?" You'll be surprised at how many difficult design issues dissolve before your eyes (p. 97).

### Identify Areas Likely to Change

Two areas likely to change that stood out to me (because of what I'm currently working on):

1. Business rules - try to keep them all contained and in the same place, rather than strewn througout your code.
2. Status variables - Use enums instead of booleans, and use getters rather than accessing the status variables directly.

### Keep Coupling Loose

#### Types of Coupling (best to worst) (p. 101-102)

- **Simple-data-parameter coupling** - simple data types passed as parameters. Normal and acceptable.
- **Simple-object coupling** - When a class or method instantiates another class. Fine.
- **Object-parameter coupling** - _Object1_ requires _Object2_ to pass it an _Object3_. Tighter than primitive data types, because it requires _Object2_ to know about _Object3_.
- **Semantic coupling** - When a class or method has some semantic knowledge of the inner workings of another class or method. Most "insidious" kind of coupling.
  - _Module1_ passes a control flag to _Module2_. This requires _Module1_ to make assumptions about what _Module2_ will do with the control flag.
  - _Module1_ expects global data to have been changed by _Module2_.